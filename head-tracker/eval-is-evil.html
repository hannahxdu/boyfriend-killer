<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' blob:">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>JS Library De-eval()-er</title>
	<style>
		body {
			font-family: 'Avenir';
			background-color: #FA7CA2;
			color: black;
		}
		
	</style>
	<link rel="stylesheet" type="text/css" href="tracky-mouse.css">
	<link rel="icon" type="image/png" sizes="16x16" href="images/tracky-mouse-logo-16.png">
	<link rel="icon" type="image/png" sizes="512x512" href="images/tracky-mouse-logo-512.png">
</head>

<body>

	<hr>

	<!-- Record code evaluations -->
	<script>
		const originalEval = eval;
		const OriginalFunction = Function;
		const evalCodes = [];
		const functionConstructions = [];
		window.eval = function(code) {
			evalCodes.push(code);
			return originalEval(code);
		};
		window.Function = function(...args) {
			const argNames = args.slice(0, -1);
			const code = args.slice(-1)[0];
			functionConstructions.push({ argNames, code });
			return new OriginalFunction(...args);
		};
	</script>

	<!-- Run code that uses eval, in a similar way to how it's normally used: -->
	<script src="lib/stats.js"></script>
	<script src="lib/clmtrackr.js"></script>
	<script src="tracky-mouse.js"></script>
	<script>
		TrackyMouse.dependenciesRoot = ".";
		TrackyMouse.init();
	</script>

	<script>
		Function("r", "regeneratorRuntime = r");
	</script>

	<!-- Generate code for eval and Function replacements -->
	<script>

		function generateMonkeyPatch() {
			let mapCode = "const evalMap = new Map();\n\t";
			for (const evalCode of evalCodes) {
				// eval supports both expressions and statements.
				// eval("1")
				// eval("var foo=1; foo;")
				// We need to detect the last expression, and turn it into a return statement.
				// eval("var foo=1; foo;") -> function() { var foo=1; return foo; }
				// eval("var foo=1;") -> function() { var foo=1; }
				// eval("foo=1;") -> function() { return foo=1; }
				// eval("1;") -> function() { return 1; }


				const potentialStatements = evalCode.replace(/(;|\s)+$/, "").split(";");
				console.log(potentialStatements);
				let fnCode = "";
				let parsed = false;
				for (let i = potentialStatements.length - 1; i >= 0; i--) {
					fnCode = potentialStatements.slice(0, i).join(";") + (i?"; ":"") + "return (" + potentialStatements.slice(i).join(";") + ");";
					try {
						new OriginalFunction(fnCode);
						parsed = true;
						break;
					} catch (e) {
						if (e instanceof SyntaxError) {
							// Continue.
						} else {
							throw e;
						}
					}
				}
				if (!parsed) {
					// The code may be just statements (i.e. with side-effects), with no return value expression.
					fnCode = evalCode;
					console.log("Leaving code as-is for function body:", evalCode);
				} else {
					console.log("Parsed eval code into function body:", {evalCode, fnCode});
				}
				
				mapCode += `evalMap.set(${JSON.stringify(evalCode)}, function() { ${fnCode} });\n\t`;
			}
			mapCode += "const functionMap = new Map();\n\t";
			for (const {argNames, code} of functionConstructions) {
				const key = JSON.stringify({argNames, code});
				try {
					new OriginalFunction(...argNames, code);
					mapCode += `functionMap.set(${JSON.stringify(key)}, function(${argNames}) { ${code} });\n\t`;
				} catch (e) {
					console.warn("Failed to parse function:", {argNames, code});
				}
			}
			const code = `// @generated by eval-is-evil.html
// 
// This is a monkey patch that replaces eval and Function
// with versions that and only run code known ahead of time.
// They do not use the real eval and Function, and thus
// the Content Security Policy (CSP) can be tightened.
(()=> {
	${mapCode}
	const eval = (code) => {
		const fn = evalMap.get(code);
		if (fn) {
			return fn();
		} else {
			throw new Error("Prevented eval of code not seen ahead-of-time on De-eval()-er page: " + code);
		}
	};
	const Function = function (...args) {
		const argNames = args.slice(0, -1);
		const code = args.slice(-1)[0];
		const key = JSON.stringify({argNames, code});
		const fn = functionMap.get(key);
		if (fn) {
			return fn;
		} else {
			throw new Error("Prevented Function constructor called with arguments not seen ahead-of-time on De-eval()-er page: " + JSON.stringify(args));
		}
	};
	// ------------------------------------------------------------
	// Insert original library code here,
	// OR export eval and Function globally:
	globalThis.eval = eval;
	globalThis.Function = Function;
	// If the original library uses ES modules, you would need to ensure
	// import/export statements remain at the top level,
	// as they're not allowed within a function.
	// ------------------------------------------------------------
})();`;
			const blob = new Blob([code], {type: "text/javascript"});
			const url = URL.createObjectURL(blob);
			const a = document.createElement("a");
			a.href = url;
			a.download = "no-eval.js";
			a.textContent = "Download no-eval.js";
			document.body.appendChild(a);
			a.style.position = "fixed";
			a.style.bottom = "10px";
			a.style.right = "10px";
			a.style.fontSize = "2em";
			a.style.color = "white";
			a.style.backgroundColor = "#07a";
			a.style.padding = "0.5em";
			a.style.borderRadius = "0.5em";
			a.style.border = "1px outset rgba(255,255,255,0.5)";
			a.style.zIndex = "1000000";
			a.style.textDecoration = "none";
			a.style.boxShadow = "0 0 0.5em 0.5em #07a2, 5px 5px 5px rgba(0,0,0,0.5)";
		}

		setTimeout(generateMonkeyPatch, 1000);

	</script>
</body>

</html>
